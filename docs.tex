\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[german]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage[parfill]{parskip}
\lstset{basicstyle=\ttfamily}
\renewcommand{\lstlistingname}{Eintrag}

\begin{document}

\section{Komponenten}

  \subsection{Traxxas Summit}

    Der Traxxas Summit ist ein per Funk gesteuertes Modell-Auto vom Hersteller Traxxas.
    Es besitzt unter anderem Servos zum Ansteuern der Funktionen und einen mit PWM gesteuerten ESC
    mit eingebautem BEC (leitet Strom des ESCs weiter an die Servos).

    Um diesen zu automatisieren, wird das Empfänger-Modul, das die Funkbefehle zur Steuerung des
    Autos empfängt, entfernt.
    Die Anschlüsse, die von dem Modul zum ESC sowie zu den Servos führten, können direkt für den
    Adafruit Servo Driver benutzt werden.

    Einige Servos können übersteuert werden weil daran angeschlossene Komponenten nur einen Teil
    des Bewegungsraumes benutzen und blockieren / stoppen wenn der Servo sich darüber hinaus
    bewegt.
    Hier muss für die einzelnen Servos software-seitig der Spielraum der PWM-Signale ausgetestet
    werden, was im Sturo-Programm für den Traxxas Summit bereits geschehen ist.

  \subsection{Raspberry Pi}

    Der Rasbperry Pi ist mit dem Adafruit Servo Driver verbunden und führt das Programm Sturo aus,
    das eine Automatisierung der Fahrt des Autos ermöglicht.
    Es können noch weitere Komponenten, wie zum Beispiel ein Ultraschall-Sensor, verbunden werden.

  \subsection{Adafruit 16-Channel 12-Bit Servo Driver}

    Dieser Servo Driver \cite{adafruitmod} erlaubt die Kontrolle der einzelnen
    Servos und des ESCs mithilfe von PWM.
    Er wird über I2C an den Raspberry Pi angeschlossen und erhält von diesem die
    Ansteuerungs-Befehle.

    Er besitzt 16 Anschlüsse (Ports) für jeweils einen Servo.
    Diese sind von 0 bis 15 durchnummeriert und können in der Software angesprochen werden.
    Für Sturo sind die folgenden Anschlüsse belegt:

    \begin{lstlisting}
Port 0    Lenkung Servo 1
Port 1    Lenkung Servo 2
Port 4    ESC (Geschwindigkeit)
Port 8    Gangschaltung
Port 9    Vordere Differentialsperre
Port 10   Hintere Differentialsperre
    \end{lstlisting}

    Weitere Anschlüsse, wie z.B. die Stromversorgung für den Spannungswandler, können beliebig auf
    die verbleibenden Ports verteilt werden.

  \subsection{Spannungswandler}

    Der Spannungswandler wandelt die Spannung (ungefähr 6V), die der BEC aus den Akkus des Autos den
    Servos zur Verfügung stellt, in eine für den Raspberry Pi nutzbare Spannung (5V) um.

    Im Projekt haben wir den BenQ DC 12V to 5V/3.3V Converter benutzt.
    Der 12V-Eingang wird an einen \lstinline{V+}-Anschluss am Servo Driver angeschlossen.
    Um Spannungsschwankungen durch die unterschiedliche Servo-Belastung zu minimieren, wird hier
    noch ein Kondensator dazwischen eingefügt.
    Der \lstinline{GND} Eingang wird ebenfalls an einen \lstinline{GND}-Anschluss (für die Servos,
    nicht dem Raspberry Pi) des Servo Drivers angeschlossen.

    Um den Spannungswandler an den Raspberry Pi anzuschließen, wurde ein Mikro-USB Kabel an einer
    Seite aufgeschnitten um das rote Kabel an den 5V Ausgang und das schwarze Kabel an den
    \lstinline{GND} Ausgang des Spannungswandlers anzuschließen.

    Nun wird der Raspberry Pi über den normalen Mikro-USB Anschluss mit Strom versorgt.

  \subsection{Ultraschallsensor}

    Der Ultraschallsensor erlaubt dem Programm die Entdeckung von Hindernissen und die korrekte
    Reaktion darauf.
    Das Projekt benutzt den Ultraschallsensor mit der Nummer \lstinline{HC-SR04}.

    Der Sensor hat vier Anschlüsse;
    \lstinline{GND} und \lstinline{VCC} können direkt an den Raspberry Pi angeschlossen werden.
    \lstinline{Echo} und \lstinline{Trig} können an beliebige GPIO Anschlüsse angebracht werden,
    Sturo geht jedoch davon aus das sie jeweils auf \lstinline{GPIO 27} und \lstinline{GPIO 22}
    angeschlossen sind.

    Sollte VCC an den 5V Anschluss des Raspberry Pis angeschlossen sein (Die 3,3V werden für I2C
    benutzt), muss man noch einen 1K Widerstand zwischen \lstinline{Echo} und den Raspberry Pi
    anbringen.

\section{Aufsetzen des Raspberry Pis}

  Das Betriebssystem des Raspberry Pis benötigt etwas Zusatzsoftware, um über das I2C-Interface mit
  dem Adafruit 16 Channel Servo Driver kommunizieren zu können.
  Im folgenden wird von Raspbian als Betriebssystem ausgegangen.
  Dieses kann von \lstinline{https://www.raspberrypi.org/} kostenlos heruntergeladen und dann auf
  die SD-Karte für den Raspberry Pi überspielt werden.

  \paragraph{I2C Software} Zuerst wird die Software zum Ansteuern des PWM-Moduls installiert:
    \begin{lstlisting}[language=sh]
sudo apt-get update
sudo apt-get install python-smbus
sudo apt-get install i2c-tools
    \end{lstlisting}

    Dann muss \lstinline{/etc/modprobe.d/raspi-blacklist.conf} überprüft werden.
    Falls die Datei die Zeile \lstinline{blacklist i2c-bcm2708} enthält, mit \lstinline{#}
    auskommentieren.
    Nun noch in \lstinline{/etc/modules} die Zeilen
    \begin{lstlisting}
i2c-dev
i2c-bcm2708
    \end{lstlisting}

    hinzufügen und den Raspberry Pi neustarten.

    Jetzt wird der Adafruit 16 Channel Servo Driver an die GPIO-Pins des Raspberry Pis
    angeschlossen.
    Mithilfe von \lstinline{sudo i2cdetect -y 0} bzw. \lstinline{sudo i2cdetect -y 1} (je nach
    Baureihe des Raspberry Pis) kann die Verbindung zwischen dem Servo Driver und dem Raspberry Pi
    überprüft werden.\cite{adafruitlearn}

  \paragraph{Sturo} Nun richten wir das Programm zur Steuerung des RC-Autos ein.

    Die aktuelle Version des Programmes befindet sich momentan auf Github:

    \begin{lstlisting}
wget https://github.com/linucc/sturo
cd sturo
chmod +x sturo_start.sh
    \end{lstlisting}

    Das Programm Sturo benötigt Python 2.7 und muss für Funktionen wie Sensoren privilegiert
    ausgeführt werden.
    Nun soll der Raspberry Pi Sturo direkt nach dem Bootvorgang ausführen.

    Dazu editiert man die Datei \lstinline{/etc/inittab}, sodass der Login beim Booten automatisch
    ausgeführt wird:

    Die Zeile \lstinline{1:2345:respawn:/sbin/getty 115200 tty1} wird mit \lstinline{#}
    auskommentiert.
    Dann kann man direkt darunter in einer neuen Zeile diesen Code einfügen:
    \begin{lstlisting}
1:2345:respawn:/bin/login -f pi tty1 </dev/tty1 >/dev/tty1 2>&1
    \end{lstlisting}
    Beim Login ist man nun als Benutzer \lstinline{Pi} eingeloggt.\cite{opentech}

    Jetzt wird die Skriptdatei aufgerufen, indem am Ende der Datei \lstinline{/etc/profile} die
    Zeile
    \begin{lstlisting}
. /home/pi/sturo/sturo_start.sh
    \end{lstlisting}
    eingefügt wird.

    Damit Sturo erweiterte Funktionen benutzen kann, muss es privilegiert mithilfe von
    \lstinline{sudo} ausgeführt werden.
    Hier wird momentan unter Umständen noch nach einem Passwort gefragt, sodass sich das Programm
    nicht automatisch startet.

    Um dies zu umgehen, können wir das \lstinline{setuid bit} auf den Nutzer \lstinline{root} setzen
    oder die \lstinline{/etc/sudoers} Datei mithilfe von \lstinline{visudo} editieren und folgende
    Zeile an das Ende fügen:
    \begin{lstlisting}
pi ALL=NOPASSWD: /usr/bin/python
    \end{lstlisting}

    Nun wird beim Ausführen von Python mit \lstinline{sudo} nicht mehr nach dem Passwort gefragt.

    Das führt in Kombination mit dem Auto-Login zu einem sehr unsicheren System, was für dieses
    Projekt aber erstmal unwichtig ist.

\section{Code-Stuffz}

\section{Herausforderungen}

\section{Abkürzungen}
  \begin{lstlisting}
ESC      Electronic Speed Controller
BEC      Battery elimination unit
PWM      Pulse-width modulation
I2C      Inter-Integrated Circuit
  \end{lstlisting}

\begin{thebibliography}{9}
  \bibitem{opentech}
    http://opentechguides.com/how-to/article/raspberry-pi/5/raspberry-pi-auto-start.html,
    Zuletzt erreicht am: 27.11.2015
  \bibitem{adafruitlearn}
    https://learn.adafruit.com/adafruit-16-channel-servo-driver-with-raspberry-pi,
    Zuletzt erreicht am: 27.11.2015
  \bibitem{adafruitmod}
    https://www.adafruit.com/product/815,
    Zuletzt erreicht am: 27.11.2015
\end{thebibliography}

\end{document}
